# Chapter 9

顺序容器
将单一元素聚集起来组成容器，然后根据位置来存储和访问这些元素。

标准库定义了三种顺序容器
+ vector
+ list
+ deque

顺序容器适配器
+ stack
+ queue
+ priority_queue

## 顺序容器的定义

所有容器都是类模块。要定义某种特殊的容器，必须在容器后面加上尖括号，里面是要存放的元素的类型。
```
vector<int> ivec;
list<string> slist;
```

所有容器都定义了默认的构造函数。

### 容器元素的初始化

```
创建一个名为c的空容器，T是元素的类型。
C(T) c;

创建容器c2的副本c，两者必须是相同类型的容器，适用于所有容器。
C c(c2);

创建c，其元素是迭代器b和e标示范围内元素的副本，适用于所有容器。
C c(b，e)；

用n个值为t的元素创建容器c。
C c(n，t)；

创建有n个值初始化的容器c。
C c(n);
```

将一个容器初始化为另一个容器的副本
当不使用默认构造函数初始化容器，必须指出容器的元素个数和初值。
同时指定这两种的方法，是创建已存在容器的一个副本。

将一个容器复制给另一个容器时，两者的容器类型和元素类型需一致。

容器内的元素必须满足以下约束
+ 元素类型必须支持赋值运算
+ 元素类型的对象必须可以复制

引用不支持赋值运算，所以没有元素是引用类型的容器。

定义容器的容器
需要用空格将>隔开
```
vector< vector<string> > lines;
```

## 迭代器

常用迭代器运算
```
返回迭代器所指向元素的引用
*iter 

对iter进行解引用，获取元素名为mem的成员
iter->mem

iter++
++iter

iter--
--iter

判断迭代器是否相等
iter1 == iter2
iter1 != iter2
```

vector和deque提供额外的操作
```
iter+n
iter-n

iter1+=iter2
iter1-=iter2

iter1-iter2
```

## 容器的类型定义和操作

### begin和end

下列操作返回一个迭代器
```
指向第一个元素
c.begin();

指向最后一个元素的下一个位置
c.end();

返回逆序迭代器，指向最后一个元素
c.rbegin();

指向第一个元素的前一个位置
c.rend();
```

### 添加元素

运用`push_back`在容器尾部添加一个元素，
list和deque还提供了`push_front`在容器首部添加元素。

使用`insert`在容器的指定位置添加元素。
```
在迭代器p所指向的元素前插入t
c.insert(p,t);

在迭代器p所指向的元素前插入n个t
c.insert(p,n,t);

在迭代器p所指向的元素前插入由迭代器b和e标记的元素
c.insert(p,b,e);
```

添加元素可能会使迭代器失效，确保在添加元素后，更新迭代器。

### 关系操作符

进行比较的容器必须具有相同的容器类型，而且元素类型也应该相同。

容器的比较是基于容器内元素的比较。
+ 如果两个容器具有相等的长度，并且元素相等，则它们相等
+ 如果两个容器的长度不等，但对应元素相等，则短的容器小于长的容器
+ 比较结果取决于第一个不相等的元素

### 容器大小的操作

```
返回容器c中的元素个数
c.size();

返回容器c可以容纳的最大元素个数
c.max_size();

返回容器是否为空的布尔值
c.empty();

调整容器的大小，如果n小于原来的元素数目，则删除多余元素；否则，采用值初始化添加新元素
c.resize(n);

调整容器大小，使其能容纳n个元素,所有新添加的元素的值为t
c.resize(n,t);
```

### 访问元素

```
返回容器c最后一个元素的引用
c.back();

返回容器c第一个元素的引用
c.front();

返回下标为n的元素的引用，只适用于vector和deque容器
c[n];

返回下标为n的元素的引用，只适用于vector和deque容器
c.at(n);
```

### 删除元素

```
删除迭代器p所指向的元素，返回一个迭代器，它指向被删除元素的下一个位置
c.erase(p);

删除迭代器b和e之间的元素，返回一个迭代器，指向被删除元素段的下一个位置
c.erase(b,e);

删除容器内的所有元素，返回void
c.clear();

删除容器c的最后一个元素
c.pop_back();

删除容器c的第一个元素，只适用list和deque容器
c.pop_front();
```

### 赋值与swap

```
删除容器c1的所有元素，然后将c2的元素复制给c1，两种容器的类型和元素类型必须相等
c1 = c2;

交换两种容器内的元素，两种容器的类型必须相等
c1.swap(c2)；

重新设置c的元素，将迭代器所指向的元素复制到c中，迭代器不能是指向c的。
c.assign(b,e);

将容器c重新设置为存储n个值为t的元素
c.assign(n,t);
```


## vector容器的自增长

为了支持快速的随机访问，vector内的元素是连续存放的，为了实现快速的内存分配，vector容器预留了存储区，用来存放新添加的元素。


### capacity和reserve

`capacity`获取容器在分配更多空间前能存储的元素总数
`reserve`则告诉容器应该预留多少个元素的空间

## 容器适配器

标准库提供了三种顺序容器适配器
+ stack
+ queue
+ priority_queue

容器适配器让一种已存在的容器类型采用另一种不同的抽象类型来工作。


### 适配器的操作和类型

```
一种足以储存该适配器类型最大长度的类型
size_type

创建一个空的适配器
A a;

创建一个新适配器，初始化为c的副本
A a(c);
```

### 栈适配器

声明语句
`stack<int> inStack;`

```
s.empty();

s.size();

s.pop();

s.top();

s.push(item);
```

### 队列和优先级队列

```
q.empty();

q.pop();

q.front();

q.back();

返回具有最高优先级的元素值
q.top();

在队尾加入值
q.push(item);

```


